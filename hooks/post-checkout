#!/bin/bash

# $1 - previous HEAD (commit hash)
# $2 - new HEAD (commit hash)
# $3 - 1 nếu là branch checkout, 0 nếu là file checkout

prev_head=$1
new_head=$2
checkout_type=$3

# Kiểm tra xem đây có phải là checkout branch không
if [ "$3" = "1" ]; then
    # Lấy tên branch hiện tại (sau khi checkout)
    new_branch=$(git rev-parse --abbrev-ref HEAD)

    # Lấy tên branch trước đó (trích từ HEAD cũ)
    # prev_branch=$(git name-rev --name-only "$1" | cut -d'^' -f1)
	prev_branch=$(git branch --contains "$prev_head" | grep -v 'detached' | grep -v '^\*' | head -1 | sed 's/^[[:space:]]*//')

	echo "Checkout từ nhánh $prev_branch sang nhánh $new_branch"

	if [ -z "$prev_branch" ]; then
	  echo "Không xác định được nhánh trước đó."
	  exit 0
	fi

    # Nếu là HEAD (detached) thì bỏ qua
    if [[ "$prev_branch" == "HEAD" ]]; then
	  	echo "Không cần xử lý vì đang ở trạng thái HEAD (detached)."
        exit 0
    fi

    # Fetch bản mới nhất từ remote cho nhánh trước đó

	# Kiểm tra nếu prev_branch tồn tại trên remote
    git fetch origin "$prev_branch" 2>/dev/null
	echo "fetch nhánh '$prev_branch' from origin."

	# Kiểm tra prev_branch tồn tại trên remote, kiểm tra xem có cần merge không
	if git show-ref --verify --quiet "refs/remotes/origin/$prev_branch"; then
		echo "Nhánh '$prev_branch' tồn tại, tiếp tục xử lý."
		# So sánh prev_head và new_head
		if [ "$prev_head" = "$new_head" ]; then
			# Kiểm tra xem local nhánh trước có khác so với remote không
			local_commit=$(git rev-parse "$prev_branch")
			remote_commit=$(git rev-parse "origin/$prev_branch")

			if [ "$local_commit" != "$remote_commit" ]; then
				echo "[post-checkout hook] Nhánh '$prev_branch' chưa phải commit mới nhất. Thực hiện merge vào '$new_branch'..."
				# Merge thay vì pull để rõ ràng
				git merge "origin/$prev_branch" --no-edit
				# Nếu muốn pull đầy đủ (bao gồm cả rebase hoặc fetch + merge)
				# git pull origin "$prev_branch"
			else
				echo "[post-checkout hook] Nhánh '$prev_branch' đã up-to-date."
			fi
		fi
	fi

	

fi